#ifndef SRC_HELPERFUNCTIONS_H_
#define SRC_HELPERFUNCTIONS_H_

#include <Eigen/Dense>
#include <math.h>
#include <cstdlib>
#include <ctime>

using namespace Eigen;
using namespace std;

void calc_F(const Eigen::VectorXd& Q,const Eigen::VectorXd& Xd, double elevator_z, Eigen::VectorXd& F)
{

	double t2;
	double t3;
	double t4;
	double t5;
	double t7;
	double t8;
	double t9;
	double t10;
	double t11;
	double t14;
	double t15;
	double t19;
	double t20;
	double t24;


	t2 = sin(Q(0));
	t3 = sin(Q(2));
	t4 = cos(Q(0));
	t5 = sin(Q(1));
	t7 = cos(Q(2));
	t8 = t2 * t3 - t4 * t5 * t7;
	t9 = cos(Q(3));
	t10 = cos(Q(1));
	t11 = sin(Q(3));
	t14 = t3 * t4 + t2 * t5 * t7;
	t15 = sin(Q(4));
	t19 = ((t5 * t9 * 0.99999999999325373 + t5 * t11 * 3.6732051033465739E-6) + t7
			* t10 * t11 * 0.99999999999325373) - t7 * t9 * t10 *
					3.6732051033465739E-6;
	t20 = cos(Q(4));
	t24 = t19 * t20 + t3 * t10 * t15;
	t15 = t15 * t19 - t3 * t10 * t20;
	F(0) = ((((((((t2 * 0.000251156 - Xd(0)) - t2 * t3 * 0.224) + t4 * t5 *
			0.266305) - t8 * t9 * 0.24475) + t8 * t11 * 0.0131003) + t4 *
			t5 * t7 * 0.224) + t4 * t9 * t10 * 0.0131003) + t4 * t10 * t11 *
			0.24475) + 0.102208;
	F(1) = (((((((t4 * -0.000251156 - Xd(1)) + t2 * t5 * 0.266305) + t3 * t4 *
			0.224) + t9 * t14 * 0.24475) - t11 * t14 * 0.0131003) + t2 * t5 *
			t7 * 0.224) + t2 * t9 * t10 * 0.0131003) + t2 * t10 * t11 * 0.24475;
	F(2) = (((((((elevator_z + t10 * 0.266305) - Xd(2)) - t5 * t9 * 0.0131003)
			- t5 * t11 * 0.24475) + t7 * t10 * 0.224) + t7 * t9 * t10 *
			0.24475) - t7 * t10 * t11 * 0.0131003) + 0.320661;
	F(3) = -Xd(3) + atan(t15 / t24);
	F(4) = -Xd(4) - atan(1.0 / sqrt(t24 * t24 + t15 * t15) * (((t5 * t9 *
			3.6732051033465739E-6 - t5 * t11 * 0.99999999999325373) + t7 * t9 * t10 *
			0.99999999999325373) + t7 * t10 * t11 * 3.6732051033465739E-6));
}

void calc_Jf(const Eigen::VectorXd& Q, Eigen::MatrixXd& Jc)
{
  double t2;
  double t3;
  double t4;
  double t5;
  double t7;
  double t9;
  double t10;
  double t11;
  double t12;
  double t14;
  double t15;
  double t16;
  double t20;
  double t23;
  double t28;
  double t29;
  double t31;
  double t33;
  double t35;
  double t38;
  double t45;
  double t48;
  double t50;
  double t51;
  double t53;
  double t56;
  double t62;
  double t63;

  /*     This function was generated by the Symbolic Math Toolbox version 6.0. */
  /*     09-Mar-2016 09:44:29 */
  t2 = cos(Q(0));
  t3 = sin(Q(0));
  t4 = sin(Q(1));
  t5 = sin(Q(2));
  t7 = cos(Q(2));
  t9 = t2 * t5 + t3 * t4 * t7;
  t10 = cos(Q(3));
  t11 = cos(Q(1));
  t12 = sin(Q(3));

  Jc(0,0) = ((((((t2 * 0.000251156 - t2 * t5 * 0.224) - t3 * t4 * 0.266305) - t9 *
              t10 * 0.24475) + t9 * t12 * 0.0131003) - t3 * t4 * t7 * 0.224) -
           t3 * t10 * t11 * 0.0131003) - t3 * t11 * t12 * 0.24475;

  t14 = t3 * t5 - t2 * t4 * t7;

  Jc(1,0) = ((((((t3 * 0.000251156 + t2 * t4 * 0.266305) - t3 * t5 * 0.224) - t10 *
              t14 * 0.24475) + t12 * t14 * 0.0131003) + t2 * t4 * t7 * 0.224) +
           t2 * t10 * t11 * 0.0131003) + t2 * t11 * t12 * 0.24475;
  Jc(2,0) = 0.0;
  Jc(3,0) = 0.0;
  Jc(4,0) = 0.0;

  Jc(0,1) = ((((t2 * t11 * 0.266305 - t2 * t4 * t10 * 0.0131003) - t2 * t4 * t12 *
             0.24475) + t2 * t7 * t11 * 0.224) + t2 * t7 * t10 * t11 * 0.24475)
    - t2 * t7 * t11 * t12 * 0.0131003;
  Jc(1,1) = ((((t3 * t11 * 0.266305 - t3 * t4 * t10 * 0.0131003) - t3 * t4 * t12 *
             0.24475) + t3 * t7 * t11 * 0.224) + t3 * t7 * t10 * t11 * 0.24475)
    - t3 * t7 * t11 * t12 * 0.0131003;
  Jc(2,1) = ((((t4 * -0.266305 - t4 * t7 * 0.224) - t10 * t11 * 0.0131003) - t11 *
            t12 * 0.24475) - t4 * t7 * t10 * 0.24475) + t4 * t7 * t12 *
    0.0131003;

  t15 = sin(Q(4));
  t16 = cos(Q(4));
  t20 = ((t4 * t10 * 0.99999999999325373 + t4 * t12 * 3.6732051033465739E-6) +
         t7 * t11 * t12 * 0.99999999999325373) - t7 * t10 * t11 *
    3.6732051033465739E-6;
  t23 = t16 * t20 + t5 * t11 * t15;
  t28 = ((t11 * t12 * 3.6732051033465739E-6 + t10 * t11 * 0.99999999999325373) +
         t4 * t7 * t10 * 3.6732051033465739E-6) - t4 * t7 * t12 *
    0.99999999999325373;
  t29 = 1.0 / (t23 * t23);
  t31 = t15 * t20 - t5 * t11 * t16;
  t33 = t31 * t31;
  t35 = t33 + t23 * t23;
  t38 = t16 * t28 - t4 * t5 * t15;
  t28 = t15 * t28 + t4 * t5 * t16;
  t45 = ((t4 * t10 * 3.6732051033465739E-6 + t7 * t10 * t11 *
          0.99999999999325373) + t7 * t11 * t12 * 3.6732051033465739E-6) - t4 *
  t12 * 0.99999999999325373;
  t48 = t3 * t7 + t2 * t4 * t5;
  t50 = t2 * t7 - t3 * t4 * t5;
  t51 = 1.0 / t23;
  t53 = t5 * t10 * t11 * 3.6732051033465739E-6 - t5 * t11 * t12 *
    0.99999999999325373;
  t56 = 1.0 / (t29 * t33 + 1.0);

  Jc(3,1) = t56 * (t28 * t51 - t29 * t31 * t38);

  t62 = 1.0 / (1.0 / t35 * (t45 * t45) + 1.0);
  t63 = 1.0 / sqrt(t35);
  t35 = 1.0 / pow(t35, 1.5);
  Jc(4,1) = t62 * (t63 * (((t10 * t11 * -3.6732051033465739E-6 + t11 * t12 *
    0.99999999999325373) + t4 * t7 * t10 * 0.99999999999325373) + t4 * t7 * t12 *
    3.6732051033465739E-6) + t45 * t35 * (t23 * t38 * 2.0 + t31 * t28 * 2.0) *
                  0.5);
  Jc(0,2) = ((t3 * t7 * -0.224 - t10 * t48 * 0.24475) + t12 * t48 * 0.0131003) -
    t2 * t4 * t5 * 0.224;
  Jc(1,2) = ((t2 * t7 * 0.224 + t10 * t50 * 0.24475) - t12 * t50 * 0.0131003) -
    t3 * t4 * t5 * 0.224;
  Jc(2,2) = (t5 * t11 * -0.224 - t5 * t10 * t11 * 0.24475) + t5 * t11 * t12 *
    0.0131003;
  t33 = t16 * t53 + t7 * t11 * t15;
  t28 = t15 * t53 - t7 * t11 * t16;
  Jc(3,2) = t56 * (t51 * t28 - t29 * t31 * t33);
  Jc(4,2) = t62 * (t63 * (t5 * t10 * t11 * 0.99999999999325373 + t5 * t11 * t12 *
    3.6732051033465739E-6) + t45 * t35 * (t23 * t33 * 2.0 + t31 * t28 * 2.0) *
                  0.5);
  Jc(0,3) = ((t10 * t14 * 0.0131003 + t12 * t14 * 0.24475) + t2 * t10 * t11 *
            0.24475) - t2 * t11 * t12 * 0.0131003;
  Jc(1,3) = ((t9 * t10 * -0.0131003 - t9 * t12 * 0.24475) + t3 * t10 * t11 *
            0.24475) - t3 * t11 * t12 * 0.0131003;
  Jc(2,3) = ((t4 * t10 * -0.24475 + t4 * t12 * 0.0131003) - t7 * t10 * t11 *
            0.0131003) - t7 * t11 * t12 * 0.24475;
  Jc(3,3) = t56 * (t15 * t45 * t51 - t16 * t29 * t31 * t45);
  Jc(4,3) = t62 * (t20 * t63 + t45 * t35 * (t16 * t23 * t45 * 2.0 + t15 * t31 *
    t45 * 2.0) * 0.5);
  Jc(0,4) = 0.0;
  Jc(1,4) = 0.0;
  Jc(2,4) = 0.0;
  Jc(3,4) = 1.0;
  Jc(4,4) = 0.0;
}

void calc_Qinit(const Eigen::VectorXd& Xd,double elevator_z, Eigen::VectorXd& Qinit)
{
  Qinit(0) = atan2(Xd(1),Xd(0));                      //theta 1
  Qinit(1) = acos((Xd(2)-elevator_z-0.3075)/0.4903);  //theta 2
  Qinit(2) = 0.0;                                     //theta 3
  Qinit(3) = M_PI/2 - Qinit(1);                       //theta 4
  Qinit(4) = 0.0;                                     //theta 5
}

void normalize_Q(Eigen::VectorXd& Q)
{
  for(int i=0; i<4; i++)
    Q(i) = fmod(Q(i),2*M_PI);
  Q(4) = fmod(Q(4),2*M_PI);
  if (Q(4)>M_PI)
    Q(4) -= 2*M_PI;
}

float RandomFloat(float LO, float HI) {
    return LO + static_cast <float> (rand()) /( static_cast <float> (RAND_MAX/(HI-LO)));
}

void randomize_Qinit(Eigen::VectorXd& Q)
{
  double        joint_limits[5][2];

  joint_limits[0][0] = -M_PI/2;
  joint_limits[0][1] = M_PI/2;
  joint_limits[1][0] = 0.0;
  joint_limits[1][1] = 1.69296;
  joint_limits[2][0] = -2.4434;
  joint_limits[2][1] = 2.4434;
  joint_limits[3][0] = -2.4434;
  joint_limits[3][1] = 2.4434;
  joint_limits[4][0] = -1.91986;
  joint_limits[4][1] = 1.91986;

  for (int i=0; i<5; i++)
    Q(i) = RandomFloat(joint_limits[i][0],joint_limits[i][1]);

}

void lockQInRange(Eigen::VectorXd& Q)
{
  double        joint_limits[5][2];

  joint_limits[0][0] = -M_PI/2;
  joint_limits[0][1] = M_PI/2;
  joint_limits[1][0] = 0.0;
  joint_limits[1][1] = 1.69296;
  joint_limits[2][0] = -2.4434;
  joint_limits[2][1] = 2.4434;
  joint_limits[3][0] = -2.4434;
  joint_limits[3][1] = 2.4434;
  joint_limits[4][0] = -1.91986;
  joint_limits[4][1] = 1.91986;

  for (int i=0; i<5; i++) {
    if (Q(i) < joint_limits[i][0])
      Q(i) = joint_limits[i][0];
    else if (Q(i) > joint_limits[i][1])
      Q(i) = joint_limits[i][1];
  }
}

bool isQInRange(Eigen::VectorXd& Q)
{
  double        joint_limits[5][2];

  joint_limits[0][0] = -M_PI/2;
  joint_limits[0][1] = M_PI/2;
  joint_limits[1][0] = 0.0;
  joint_limits[1][1] = 1.69296;
  joint_limits[2][0] = -2.4434;
  joint_limits[2][1] = 2.4434;
  joint_limits[3][0] = -2.4434;
  joint_limits[3][1] = 2.4434;
  joint_limits[4][0] = -1.91986;
  joint_limits[4][1] = 1.91986;

  for (int i=0; i<5; i++) {
    if (Q(i)<joint_limits[i][0] || Q(i)>joint_limits[i][1])
      return false;
  }
  return true;
}

std::vector<double>  IK(geometry_msgs::Pose desired_pose){

  const int MAX_ITERATION = 2000;
  const int MAX_ATTEMPTS  = 500;
  VectorXd Q(5);
  VectorXd new_Q(5);
  VectorXd F(5);
  VectorXd Xd(5);
  MatrixXd Jc(5,5);

  const double elevator_z = 0.4;

  std::vector<double> group_variable_values; // return value
  group_variable_values.resize(5);

  Xd << desired_pose.position.x,
      desired_pose.position.y,
      desired_pose.position.z,
      0.0,
      0.0;

  bool solution = false;

  int iter, counts = 0;
  srand (static_cast <unsigned> (time(0)));
  while ( (!solution) && (counts<MAX_ATTEMPTS) ) {
    iter = 0;
    randomize_Qinit(Q);
    while ( (!solution) && (iter<MAX_ITERATION) )   {
      calc_F(Q,Xd,elevator_z,F);
      calc_Jf(Q,Jc);
      new_Q = Q - 0.01 * Jc.inverse() * F;
      normalize_Q(new_Q);
      if ((new_Q - Q).norm()<=1E-6 && isQInRange(new_Q)) {
        solution = true;
      }
      Q = new_Q;
      iter++;
    }
    counts++;
  }

  if (!solution) {
    cout << " NO SOLUTION FOUND" << endl;
    return group_variable_values;
  }
  else {
    cout << "attempt: " << counts << " iter = "<< iter << endl;

    group_variable_values[0] =  Q(0) ;
    group_variable_values[1] =  Q(1) ;
    group_variable_values[2] =  Q(2) ;
    group_variable_values[3] =  Q(3) ;
    group_variable_values[4] =  Q(4) ;

    return group_variable_values ;
  }

}


#endif /* SRC_HELPERFUNCTIONS_H_ */
